内存分配策略
	对象的内存分配，往大方向上讲，就是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB(本地线程分配缓冲)上分配。少数情况下也会直接分配在老年代上。
几个策略：
1.对象优先在Eden区分配
	大多数情况下，对象在新生代Eden区中分配。当Eden区中没有足够的空间进行分配时，虚拟机将发起一次Minor GC.
2. 大对象直接进入老年代
	所谓大对象，是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串及数组。大对象对虚拟机的内存分配来说就是一个坏消息，尤其是短命的大对象。
	虚拟机提供了参数-XX:PretenureSizeThreadshold，另大于这个设置值的对象直接在老年代中分配。

3.长期存活的对象将进入老年代
	虚拟机给每个对象定义一个对象年龄计数器，如果第一次被移入Survivor空间中，对象年龄设为1.在Survivor区中没熬过一次Minor GC,年龄就增加1，当它的年龄增加到一定的程序(默认为15)时，就会被晋升到老年代中。这个年龄阀值可以设置。
4.动态对象年龄判定
	为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreashold才能晋升到老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreashold中要求的年龄。
5.空间分配担保
	在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC.如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，只会进行Minor GC,如果不允许，则改为进行一次Full GC.大部分情况下，HandlePromotionFailure开关是开的，允许担保失败，这样就避免了Full GC过于频繁。

ps:
Minor GC和Full GC
Minor GC(新生代GC)：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
Full GC/Major GC(老年代GC):指发生在老年代的GC,经常会伴随至少一次的Minor GC(也不绝对)。Full GC速度一般比Minor GC慢10倍
